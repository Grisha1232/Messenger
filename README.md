# Messenger
simple messenger

Изначально запускается сервер
### Сценарий сервера:
1. Создается аксептор который будет принимать новый подключения
2. присваиваются handler'ы для обработки событий (подключения, отключения, сообщение от клиента)
3. далее запускается сервер: заускается цикл принятия новых подключений на сервер, запускается io_context.
> принятия подключений на сервер происходит ассинхронно методом async_accept(...), если никакой ошибки не возникает при подклчение, то создается TCPConnection (подключение к клиенту) и стартует его обработку. 

4. После того как создалось подключение к сокету клиента (полю user_name_ присваевается значение socket_.remote_endpoint()), начинает ассинхронно читать приходящие с этого сокета сообщения до появления символа '\n'.
5. Как только появляется символ '\n' вызывается функция onRead(...)
6. если не произошло никакой ошибки проверяется сообщение на наличие в нем ключегого слова "--login--" и проверка на соответсвие user_name_ с socket_.remote_endpoint(), если это так (они равны), то в user_name_ записывается сообщение без "--login--", при условии, что такого имени в подключенных клиентах нет и отправляет сообщение клиентам, которые подключены в данный момент, о том, что присоеденился такой-то пользователь
7. если предыдущая проверка не прошла => это просто отправка сообщения от клиента и вызывается message_handler(message), который в свою очередь вызывает onClientMessage(message) - вещает всем подсоединеным клиентам сообщение посредствам метода postMessage у TCPConnection (чтобы вызвать этот метод у всех, храним unordered_set всех TCPConnection в TCPServer)
8. TCPConnection::postMessage(message) - функция, которая помещает в очередь сообщение и запускает "цикл" вызовов отправки сообщений если очередь не пуста (postMessage -> asyncWrite -> onWrite -> asyncWrite ...) 
9. Все это повторяется до того момента пока клиент отправляет сообщения на сокет сервера и не выходит.
10. Если клиент отсоединяется от сокета сервера (то есть происходит сбой подклчение к сокету клиента) вызывается error_handler_(), который удаляет из сохраненых никнеймов клиентов никнейм клиента, который отсоеденился, и удаляет подключение данного сокета из сохраненных (connections_.erase())
11. И отправляет соответсвующее сообщение остальным клиентам о том, что такой-то пользователь отсоеденился

далее после того как сервер запустился клиенты могут подключаться к мессенджеру
### Сценарий клиента:
1. При запуске программы создается объект TCPClient, который создает сокет подключения к серверу (с параметрами address: "localhost", port: 12345), после чего в отдельном потоке запускается ассинхронное подключение к данному сокету, и при успешном подключении наинает ассинхронно читать сообщения от сервера.
2. Далее вылезает диалоговое окно, которое спрашивает никнейм у пользователя.
3. При нажатии на кнопку "login" происходит отправка сообщения на сокет сервера с текстом "--login--<username>", где username - это то, что набрал пользователь в поле ввода диалогового окна.
4. Если сервер принимает это имя он присылает ответ пользователю на его сокет с сообщением "ok" (отправляется только тому пользователю, который логинится)
5. Иначе появится сообщение о том, что этот никнейм нельзя использовать (потому, что он испольлзуется уже кем-то другим в чате)
5. После успешного логирования, появляется главное окно с чатом, полем ввода и кнопкой отправить сообщение.
6. При нажатии кнопки отправить ("send") происходит отправка сообщения на сокет сервера с текстом, который пользователь ввел в поле ввода (происходит тоже самое, что и при отправке сообщения сервером, методы практически идентичны)
7. При отключения пользователь, то есть нажатия на кнопку закрытия окна, всем остальным пользователям, которые подключены к серверу, присылается об этом сообщение
